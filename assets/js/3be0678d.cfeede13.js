"use strict";(self.webpackChunkshenyu_website=self.webpackChunkshenyu_website||[]).push([[40538],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),h=r,g=d["".concat(l,".").concat(h)]||d[h]||c[h]||a;return n?i.createElement(g,o(o({ref:t},u),{},{components:n})):i.createElement(g,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<a;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},20309:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=n(87462),r=(n(67294),n(3905));const a={title:"Register Center Source Code Analysis of Http Register",author:"midnight2104",author_title:"Apache ShenYu Committer",author_url:"https://github.com/midnight2104",tags:["http","register center","Apache ShenYu"]},o=void 0,s={permalink:"/blog/RegisterCenter-SourceCode-Analysis-Http-Register",editUrl:"https://github.com/apache/incubator-shenyu-website/edit/main/blog/RegisterCenter-SourceCode-Analysis-Http-Register.md",source:"@site/blog/RegisterCenter-SourceCode-Analysis-Http-Register.md",title:"Register Center Source Code Analysis of Http Register",description:"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.",date:"2022-07-22T02:50:21.622Z",formattedDate:"July 22, 2022",tags:[{label:"http",permalink:"/blog/tags/http"},{label:"register center",permalink:"/blog/tags/register-center"},{label:"Apache ShenYu",permalink:"/blog/tags/apache-shen-yu"}],readingTime:28.855,truncated:!1,prevItem:{title:"Code Analysis For Dubbo Plugin",permalink:"/blog/Plugin-SourceCode-Analysis-Dubbo-Plugin"},nextItem:{title:"PredicateJudge -- analyze the design based on SPI",permalink:"/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI"}},l=[{value:"1. Registration Center Principle",id:"1-registration-center-principle",children:[]},{value:"2. Client Registration Process",id:"2-client-registration-process",children:[]},{value:"3. Server-side registration process",id:"3-server-side-registration-process",children:[]},{value:"4. Summary",id:"4-summary",children:[]}],p={toc:l};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,i.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/zh/docs/index"},"Apache ShenYu")," is an asynchronous, high-performance, cross-language, responsive API gateway.")),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenYu")," gateway, the registration center is used to register the client information to ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," then synchronizes this information to the gateway through data synchronization, and the gateway completes traffic filtering through these data. The client information mainly includes ",(0,r.kt)("inlineCode",{parentName:"p"},"interface information")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI information"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"This article is based on ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-2.4.1")," version for source code analysis, please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/zh/docs/design/register-center-design"},"Client Access Principles")," for the introduction of the official website.")),(0,r.kt)("h3",{id:"1-registration-center-principle"},"1. Registration Center Principle"),(0,r.kt)("p",null,"When the client starts, it reads the interface information and ",(0,r.kt)("inlineCode",{parentName:"p"},"uri information"),", and sends the data to ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin")," by the specified registration type."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(34177).Z})),(0,r.kt)("p",null,"The registration center in the figure requires the user to specify which registration type to use. ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenYu")," currently supports ",(0,r.kt)("inlineCode",{parentName:"p"},"Http"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Zookeeper"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Etcd"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Consul")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Nacos")," for registration. Please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/zh/docs/user-guide/register-center-access"},"Client Access Configuration")," for details on how to configure them."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShenYu")," introduces ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," in the principle design of the registration center, in which the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue plays a role in decoupling data and operations, which is conducive to expansion. If too many registration requests lead to registration exceptions, it also has a data buffering role."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(10318).Z})),(0,r.kt)("p",null,"As shown in the figure, the registration center is divided into two parts, one is the registration center client ",(0,r.kt)("inlineCode",{parentName:"p"},"register-client"),", the load processing client data reading. The other is the registration center server ",(0,r.kt)("inlineCode",{parentName:"p"},"register-server"),", which is loaded to handle the server side (that is ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin"),") data writing. Data is sent and received by specifying the registration type."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Client: Usually it is a microservice, which can be ",(0,r.kt)("inlineCode",{parentName:"li"},"springmvc"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"spring-cloud"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"dubbo"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"grpc"),", etc."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"register-client"),": register the central client, read the client interface and ",(0,r.kt)("inlineCode",{parentName:"li"},"uri")," information."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Disruptor"),": decoupling data from operations, data buffering role."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"register-server"),": registry server, here is ",(0,r.kt)("inlineCode",{parentName:"li"},"shenyu-admin"),", receive data, write to database, send data synchronization events."),(0,r.kt)("li",{parentName:"ul"},"registration-type: specify the registration type, complete data registration, currently supports ",(0,r.kt)("inlineCode",{parentName:"li"},"Http"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Zookeeper"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Consul")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Nacos"),".")),(0,r.kt)("p",null,"This article analyzes the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"Http")," for registration, so the specific processing flow is as follows."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(13210).Z})),(0,r.kt)("p",null,"On the client side, after the data is out of the queue, the data is transferred via ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," and on the server side, the corresponding interface is provided to receive the data and then write it to the queue."),(0,r.kt)("h3",{id:"2-client-registration-process"},"2. Client Registration Process"),(0,r.kt)("p",null,"When the client starts, it reads the attribute information according to the relevant configuration, and then writes it to the queue. Let's take the official ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/apache/incubator-shenyu/tree/master/shenyu-examples/shenyu-examples-http"},"shenyu-examples-http")," as an example and start the source code analysis . The official example is a microservice built by ",(0,r.kt)("inlineCode",{parentName:"p"},"springboot"),". For the configuration of the registration center, please refer to the official website ",(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/zh/docs/user-guide/register-center-access"},"client access configuration")," ."),(0,r.kt)("h4",{id:"21-load-configuration-read-properties"},"2.1 Load configuration, read properties"),(0,r.kt)("p",null,"Let's start with a diagram that ties together the initialization process of the registry client."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(98557).Z})),(0,r.kt)("p",null,"We are analyzing registration by means of ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),", so the following configuration is required."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},"shenyu:\n  register:\n    registerType: http\n    serverLists: http://localhost:9095\n  client:\n    http:\n        props:\n          contextPath: /http\n          appName: http\n          port: 8189  \n          isFull: false\n")),(0,r.kt)("p",null,"Each attribute indicates the following meaning."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"registerType"),": the service registration type, fill in ",(0,r.kt)("inlineCode",{parentName:"li"},"http"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"serverList"),": The address of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Shenyu-Admin")," project to fill in for the ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," registration type, note the addition of ",(0,r.kt)("inlineCode",{parentName:"li"},"http://")," and separate multiple addresses with English commas."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"port"),": the start port of your project, currently ",(0,r.kt)("inlineCode",{parentName:"li"},"springmvc/tars/grpc")," needs to be filled in."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"contextPath"),": the routing prefix for your ",(0,r.kt)("inlineCode",{parentName:"li"},"mvc")," project in ",(0,r.kt)("inlineCode",{parentName:"li"},"shenyu")," gateway, such as ",(0,r.kt)("inlineCode",{parentName:"li"},"/order"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"/product"),", etc. The gateway will route according to your prefix."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"appName"),": the name of your application, if not configured, it will take the value of ",(0,r.kt)("inlineCode",{parentName:"li"},"spring.application.name")," by default."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"isFull"),": set ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," to proxy your entire service, ",(0,r.kt)("inlineCode",{parentName:"li"},"false")," to proxy one of your ",(0,r.kt)("inlineCode",{parentName:"li"},"controllers"),"; currently applies to ",(0,r.kt)("inlineCode",{parentName:"li"},"springmvc/springcloud"),".")),(0,r.kt)("p",null,"After the project starts, it will first load the configuration file, read the property information and generate the corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"Bean"),"."),(0,r.kt)("p",null,"The first configuration file read is ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuSpringMvcClientConfiguration"),", which is the ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," registration configuration class for the ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu")," client, indicated by ",(0,r.kt)("inlineCode",{parentName:"p"},"@Configuration")," which is a configuration class, and by ",(0,r.kt)("inlineCode",{parentName:"p"},"@ImportAutoConfiguration")," which is a configuration class. to introduce other configuration classes. Create ",(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvcClientBeanPostProcessor"),", which mainly handles metadata. Create ",(0,r.kt)("inlineCode",{parentName:"p"},"ContextRegisterListener"),", which mainly handles ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Shenyu SpringMvc Client Configuration\n */\n@Configuration\n@ImportAutoConfiguration(ShenyuClientCommonBeanConfiguration.class)\npublic class ShenyuSpringMvcClientConfiguration {\n\n    //create SpringMvcClientBeanPostProcessor to handle metadata\n    @Bean\n    public SpringMvcClientBeanPostProcessor springHttpClientBeanPostProcessor(final ShenyuClientConfig clientConfig,final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\n        return new SpringMvcClientBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()), shenyuClientRegisterRepository);\n    }\n    \n   //create ContextRegisterListener to handle URI\n    @Bean\n    public ContextRegisterListener contextRegisterListener(final ShenyuClientConfig clientConfig) {\n        return new ContextRegisterListener(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()));\n    }\n}\n\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientCommonBeanConfiguration")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu")," client common configuration class that will create the ",(0,r.kt)("inlineCode",{parentName:"p"},"bean")," common to the registry client."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterRepository"),", which is created by factory class."),(0,r.kt)("li",{parentName:"ul"},"Create ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuRegisterCenterConfig"),", which reads the ",(0,r.kt)("inlineCode",{parentName:"li"},"shenyu.register")," property configuration."),(0,r.kt)("li",{parentName:"ul"},"Create ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientConfig"),", read the ",(0,r.kt)("inlineCode",{parentName:"li"},"shenyu.client")," property configuration.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n * Shenyu Client Common Bean Configuration\n */\n@Configuration\npublic class ShenyuClientCommonBeanConfiguration {\n    \n   // create ShenyuClientRegisterRepository by factory \n    @Bean\n    public ShenyuClientRegisterRepository shenyuClientRegisterRepository(final ShenyuRegisterCenterConfig config) {\n        return ShenyuClientRegisterRepositoryFactory.newInstance(config);\n    }\n    \n    // create ShenyuRegisterCenterConfig to read shenyu.register properties\n    @Bean\n    @ConfigurationProperties(prefix = "shenyu.register")\n    public ShenyuRegisterCenterConfig shenyuRegisterCenterConfig() {\n        return new ShenyuRegisterCenterConfig();\n    }\n    \n  // create ShenyuClientConfig to read shenyu.client properties\n    @Bean\n    @ConfigurationProperties(prefix = "shenyu")\n    public ShenyuClientConfig shenyuClientConfig() {\n        return new ShenyuClientConfig();\n    }\n}\n\n')),(0,r.kt)("h4",{id:"22-httpclientregisterrepository"},"2.2 HttpClientRegisterRepository"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterRepository")," generated in the configuration file above is a concrete implementation of the client registration, which is an interface with the following implementation class."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(47868).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HttpClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"http"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ConsulClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Consul"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EtcdClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),"; ",(0,r.kt)("inlineCode",{parentName:"li"},"EtcdClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NacosClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"nacos"),"; ",(0,r.kt)("inlineCode",{parentName:"li"},"NacosClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"nacos"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZookeeperClientRegisterRepository"),": registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Zookeeper"),".")),(0,r.kt)("p",null,"The specific way which is achieved by loading through ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),", the implementation logic is as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n * load ShenyuClientRegisterRepository\n */\npublic final class ShenyuClientRegisterRepositoryFactory {\n    \n    private static final Map<String, ShenyuClientRegisterRepository> REPOSITORY_MAP = new ConcurrentHashMap<>();\n    \n    /**\n     * create ShenyuClientRegisterRepository\n     */\n    public static ShenyuClientRegisterRepository newInstance(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig) {\n        if (!REPOSITORY_MAP.containsKey(shenyuRegisterCenterConfig.getRegisterType())) {\n            // Loading by means of SPI, type determined by registerType\n            ShenyuClientRegisterRepository result = ExtensionLoader.getExtensionLoader(ShenyuClientRegisterRepository.class).getJoin(shenyuRegisterCenterConfig.getRegisterType());\n            //init ShenyuClientRegisterRepository\n            result.init(shenyuRegisterCenterConfig);\n            ShenyuClientShutdownHook.set(result, shenyuRegisterCenterConfig.getProps());\n            REPOSITORY_MAP.put(shenyuRegisterCenterConfig.getRegisterType(), result);\n            return result;\n        }\n        return REPOSITORY_MAP.get(shenyuRegisterCenterConfig.getRegisterType());\n    }\n}\n")),(0,r.kt)("p",null,"The load type is specified by ",(0,r.kt)("inlineCode",{parentName:"p"},"registerType"),", which is the type we specify in the configuration file at"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},"shenyu:\n  register:\n    registerType: http\n    serverLists: http://localhost:9095\n")),(0,r.kt)("p",null,"We specified ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),", so it will go to load ",(0,r.kt)("inlineCode",{parentName:"p"},"HttpClientRegisterRepository"),". After the object is successfully created, the initialization method ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," is executed as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Join\npublic class HttpClientRegisterRepository implements ShenyuClientRegisterRepository {\n    \n    @Override\n    public void init(final ShenyuRegisterCenterConfig config) {\n        this.serverList = Lists.newArrayList(Splitter.on(",").split(config.getServerLists()));\n    }\n  \n  // ......\n}\n')),(0,r.kt)("p",null,"Read ",(0,r.kt)("inlineCode",{parentName:"p"},"serverLists")," from the configuration file, the address of ",(0,r.kt)("inlineCode",{parentName:"p"},"sheenyu-admin"),", in preparation for subsequent data sending. The class annotation ",(0,r.kt)("inlineCode",{parentName:"p"},"@Join")," is used for ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI")," loading."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),", known as ",(0,r.kt)("inlineCode",{parentName:"p"},"Service Provider Interface"),", is a service provider discovery feature built into the ",(0,r.kt)("inlineCode",{parentName:"p"},"JDK"),", a mechanism for dynamic replacement discovery."),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/apache/incubator-shenyu/tree/master/shenyu-spi"},"shenyu-spi")," is a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI")," extension implementation for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Apache ShenYu")," gateway, designed and implemented with reference to Dubbo ",(0,r.kt)("a",{parentName:"p",href:"https://dubbo.apache.org/zh/docs/v2.7/dev/impls/"},"SPI extension implementation"),".")),(0,r.kt)("h4",{id:"23-springmvcclientbeanpostprocessor"},"2.3 SpringMvcClientBeanPostProcessor"),(0,r.kt)("p",null,"Create ",(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvcClientBeanPostProcessor"),", which is responsible for metadata construction and registration, with the following constructor logic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n *  spring mvc client BeanPostProcessor\n */\npublic class SpringMvcClientBeanPostProcessor implements BeanPostProcessor {\n\n    /**\n     * Instantiation by constructor\n     */\n    public SpringMvcClientBeanPostProcessor(final PropertiesConfig clientConfig,\n                                            final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\n        // read Properties\n        Properties props = clientConfig.getProps();\n        // get port information and verify\n        int port = Integer.parseInt(props.getProperty(ShenyuClientConstants.PORT));\n        if (port <= 0) {\n            String errorMsg = "http register param must config the port must > 0";\n            LOG.error(errorMsg);\n            throw new ShenyuClientIllegalArgumentException(errorMsg);\n        }\n        // get appName\n        this.appName = props.getProperty(ShenyuClientConstants.APP_NAME);\n        // get contextPath\n        this.contextPath = props.getProperty(ShenyuClientConstants.CONTEXT_PATH);\n        // check appName and contextPath\n        if (StringUtils.isBlank(appName) && StringUtils.isBlank(contextPath)) {\n            String errorMsg = "http register param must config the appName or contextPath";\n            LOG.error(errorMsg);\n            throw new ShenyuClientIllegalArgumentException(errorMsg);\n        }\n        // get isFull\n        this.isFull = Boolean.parseBoolean(props.getProperty(ShenyuClientConstants.IS_FULL, Boolean.FALSE.toString()));\n        // start publisher\n        publisher.start(shenyuClientRegisterRepository);\n    }\n\n    // ......\n    @Override\n    public Object postProcessAfterInitialization(@NonNull final Object bean, @NonNull final String beanName) throws BeansException {\n      // ......\n    }\n\n}\n\n')),(0,r.kt)("p",null,"In the constructor, the main purpose is to read the property information and then perform the checksum."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},"shenyu:\n  client:\n    http:\n        props:\n          contextPath: /http\n          appName: http\n          port: 8189  \n          isFull: false\n")),(0,r.kt)("p",null,"Finally, ",(0,r.kt)("inlineCode",{parentName:"p"},"publisher.start()")," is executed to start event publishing and prepare for registration."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ShenyuClientRegisterEventPublisher")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterEventPublisher")," is implemented via singleton pattern, mainly generating ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," subscribers (subsequently used for data publishing), and then starting the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue. A common method ",(0,r.kt)("inlineCode",{parentName:"p"},"publishEvent()")," is provided to publish events and send data to the Disruptor queue."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic class ShenyuClientRegisterEventPublisher {\n    private static final ShenyuClientRegisterEventPublisher INSTANCE = new ShenyuClientRegisterEventPublisher();\n    \n    private DisruptorProviderManage providerManage;\n    \n    private RegisterClientExecutorFactory factory;\n    \n    public static ShenyuClientRegisterEventPublisher getInstance() {\n        return INSTANCE;\n    }\n    \n    public void start(final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\n        factory = new RegisterClientExecutorFactory();\n        factory.addSubscribers(new ShenyuClientMetadataExecutorSubscriber(shenyuClientRegisterRepository));\n        factory.addSubscribers(new ShenyuClientURIExecutorSubscriber(shenyuClientRegisterRepository));\n        providerManage = new DisruptorProviderManage(factory);\n        providerManage.startup();\n    }\n    \n    public <T> void publishEvent(final T data) {\n        DisruptorProvider<Object> provider = providerManage.getProvider();\n        provider.onData(f -> f.setData(data));\n    }\n}\n")),(0,r.kt)("p",null,"The logic of the constructor of ",(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvcClientBeanPostProcessor")," is analyzed, it mainly reads the property configuration, creates metadata and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," subscribers, and starts the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue. It is important to note that it implements ",(0,r.kt)("inlineCode",{parentName:"p"},"BeanPostProcessor"),", an interface provided by ",(0,r.kt)("inlineCode",{parentName:"p"},"Spring")," that executes the ",(0,r.kt)("inlineCode",{parentName:"p"},"postProcessAfterInitialization()")," method of the post-processor before it actually starts to be used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Bean")," lifecycle."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"postProcessAfterInitialization() ")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvcClientBeanPostProcessor")," acts as a post-processor which does the following: reads the metadata in the annotation and registers it with ",(0,r.kt)("inlineCode",{parentName:"p"},"admin"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class SpringMvcClientBeanPostProcessor implements BeanPostProcessor {\n   // ......\n    \n    // reads the metadata in the annotation and registers it with admin\n    @Override\n    public Object postProcessAfterInitialization(@NonNull final Object bean, @NonNull final String beanName) throws BeansException {\n        // Configuration attribute, if isFull=true, means register the whole microservice\n        if (isFull) {\n            return bean;\n        }\n        // get Controller annotation\n        Controller controller = AnnotationUtils.findAnnotation(bean.getClass(), Controller.class);\n         // get RequestMapping annotation\n        RequestMapping requestMapping = AnnotationUtils.findAnnotation(bean.getClass(), RequestMapping.class);\n        if (controller != null || requestMapping != null) {\n             // get the ShenyuSpringMvcClient annotation for the current bean\n            ShenyuSpringMvcClient clazzAnnotation = AnnotationUtils.findAnnotation(bean.getClass(), ShenyuSpringMvcClient.class);\n            String prePath = "";\n            // If there is no ShenyuSpringMvcClient annotation, it is returned, indicating that the interface does not need to be registered\n            if (Objects.isNull(clazzAnnotation)) {\n                return bean;\n            }\n             // If the path attribute of the ShenyuSpringMvcClient annotation includes *, it means that the entire interface is registered\n            if (clazzAnnotation.path().indexOf("*") > 1) {\n                // build metadata, publish registration event\n                publisher.publishEvent(buildMetaDataDTO(clazzAnnotation, prePath));\n                return bean;\n            }\n            \n            prePath = clazzAnnotation.path();\n            // get all methods of the current bean\n            final Method[] methods = ReflectionUtils.getUniqueDeclaredMethods(bean.getClass());\n            for (Method method : methods) {\n                // get ShenyuSpringMvcClient annotation\n                ShenyuSpringMvcClient shenyuSpringMvcClient = AnnotationUtils.findAnnotation(method, ShenyuSpringMvcClient.class);\n                // If the method has the annotation ShenyuSpringMvcClient, it means that the method needs to be registered\n                if (Objects.nonNull(shenyuSpringMvcClient)) {\n                    // build metadata, publish registration event\n                    publisher.publishEvent(buildMetaDataDTO(shenyuSpringMvcClient, prePath));\n                }\n            }\n        }\n        return bean;\n    }\n\n    // build metadata\n    private MetaDataRegisterDTO buildMetaDataDTO(final ShenyuSpringMvcClient shenyuSpringMvcClient, final String prePath) {\n        // contextPath\n        String contextPath = this.contextPath;\n        // appName\n        String appName = this.appName;\n        // path\n        String path;\n        if (StringUtils.isEmpty(contextPath)) {\n            path = prePath + shenyuSpringMvcClient.path();\n        } else {\n            path = contextPath + prePath + shenyuSpringMvcClient.path();\n        }\n        // desc info\n        String desc = shenyuSpringMvcClient.desc();\n        // ruleName\n        String configRuleName = shenyuSpringMvcClient.ruleName();\n        String ruleName = StringUtils.isBlank(configRuleName) ? path : configRuleName;\n        return MetaDataRegisterDTO.builder()\n                .contextPath(contextPath)\n                .appName(appName)\n                .path(path)\n                .pathDesc(desc)\n                .rpcType(RpcTypeEnum.HTTP.getName())\n                .enabled(shenyuSpringMvcClient.enabled())\n                .ruleName(ruleName)\n                .registerMetaData(shenyuSpringMvcClient.registerMetaData())\n                .build();\n    }\n}\n\n')),(0,r.kt)("p",null,"In the post-processor, you need to read the configuration property, if ",(0,r.kt)("inlineCode",{parentName:"p"},"isFull=true"),", it means register the whole microservice. Get the ",(0,r.kt)("inlineCode",{parentName:"p"},"Controller")," annotation, ",(0,r.kt)("inlineCode",{parentName:"p"},"RequestMapping")," annotation, ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuSpringMvcClient")," annotation of the current ",(0,r.kt)("inlineCode",{parentName:"p"},"bean")," and determine if the current ",(0,r.kt)("inlineCode",{parentName:"p"},"bean")," is an interface by reading these annotations? Does the interface need to be registered? Does the method need to be registered? Then build metadata based on the properties in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuSpringMvcClient")," annotation, and finally publish the event for registration via ",(0,r.kt)("inlineCode",{parentName:"p"},"publisher.publishEvent()"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Controller")," annotation and the ",(0,r.kt)("inlineCode",{parentName:"p"},"RequestMapping")," annotation are provided by ",(0,r.kt)("inlineCode",{parentName:"p"},"Spring"),", which you should be familiar with, so I won't go into details. The ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuSpringMvcClient")," annotation is provided by ",(0,r.kt)("inlineCode",{parentName:"p"},"Apache ShenYu")," to register the ",(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvc")," client, which is defined as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n * ShenyuSpringMvcClient\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface ShenyuSpringMvcClient {\n    // path \n    String path();\n    \n    // ruleName \n    String ruleName() default "";\n    \n    // desc info\n    String desc() default "";\n\n    // enabled\n    boolean enabled() default true;\n    \n    // register MetaData \n    boolean  registerMetaData() default false;\n}\n\n')),(0,r.kt)("p",null,"It is used as follows."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"register the entire interface")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@RestController\n@RequestMapping("/test")\n@ShenyuSpringMvcClient(path = "/test/**")  // register the entire interface\npublic class HttpTestController {\n //......\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"register current method")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@RestController\n@RequestMapping("/order")\n@ShenyuSpringMvcClient(path = "/order")\npublic class OrderController {\n\n    /**\n     * Save order dto.\n     *\n     * @param orderDTO the order dto\n     * @return the order dto\n     */\n    @PostMapping("/save")\n    @ShenyuSpringMvcClient(path = "/save", desc = "Save order") // register current method\n    public OrderDTO save(@RequestBody final OrderDTO orderDTO) {\n        orderDTO.setName("hello world save order");\n        return orderDTO;\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"publisher.publishEvent() ")),(0,r.kt)("p",null,"This method sends the data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue. More details about the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue are not described here, which does not affect the flow of analyzing the registration."),(0,r.kt)("p",null,"When the data is sent, the consumers of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue will process the data for consumption."),(0,r.kt)("p",null,"This method sends the data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue. More details about the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue are not described here, which does not affect the flow of analyzing the registration."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"QueueConsumer ")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumer")," is a consumer that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"WorkHandler")," interface, which is created in the ",(0,r.kt)("inlineCode",{parentName:"p"},"providerManage.startup()")," logic. The ",(0,r.kt)("inlineCode",{parentName:"p"},"WorkHandler")," interface is the data consumption interface for ",(0,r.kt)("inlineCode",{parentName:"p"},"disruptor"),", and the only method is ",(0,r.kt)("inlineCode",{parentName:"p"},"onEvent()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"package com.lmax.disruptor;\n\npublic interface WorkHandler<T> {\n    void onEvent(T var1) throws Exception;\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumer")," overrides the ",(0,r.kt)("inlineCode",{parentName:"p"},"onEvent()")," method, and the main logic is to generate the consumption task and then go to the thread pool to execute it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n * \n * QueueConsumer\n */\npublic class QueueConsumer<T> implements WorkHandler<DataEvent<T>> {\n    \n    // ......\n\n    @Override\n    public void onEvent(final DataEvent<T> t) {\n        if (t != null) {\n            // create queue consumption tasks via factory\n            QueueConsumerExecutor<T> queueConsumerExecutor = factory.create();\n            // set data\n            queueConsumerExecutor.setData(t.getData());\n            // help gc\n            t.setData(null);\n            // put in the thread pool to execute the consumption task\n            executor.execute(queueConsumerExecutor);\n        }\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumerExecutor")," is the task that is executed in the thread pool, it implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runnable")," interface, and there are two specific implementation classes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterClientConsumerExecutor"),": the client-side consumer executor."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterServerConsumerExecutor"),": server-side consumer executor.")),(0,r.kt)("p",null,"As the name implies, one is responsible for handling client-side tasks, and one is responsible for handling server-side tasks (the server side is ",(0,r.kt)("inlineCode",{parentName:"p"},"admin"),", which is analyzed below)."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(5847).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"RegisterClientConsumerExecutor ")),(0,r.kt)("p",null,"The logic of the rewritten ",(0,r.kt)("inlineCode",{parentName:"p"},"run()")," is as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic final class RegisterClientConsumerExecutor extends QueueConsumerExecutor<DataTypeParent> {\n    \n    //...... \n\n    @Override\n    public void run() {\n        // get data\n        DataTypeParent dataTypeParent = getData();\n        // call the appropriate processor for processing according to the data type\n        subscribers.get(dataTypeParent.getType()).executor(Lists.newArrayList(dataTypeParent));\n    }\n    \n}\n")),(0,r.kt)("p",null,"Different processors are called to perform the corresponding tasks based on different data types. There are two types of data, one is metadata, which records the client registration information. One is the ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data, which records the client service information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public enum DataType {\n \n    META_DATA,\n  \n    URI,\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ExecutorSubscriber#executor() ")),(0,r.kt)("p",null,"The actuator subscribers are also divided into two categories, one that handles metadata and one that handles ",(0,r.kt)("inlineCode",{parentName:"p"},"URIs"),". There are two on the client side and two on the server side, so there are four in total."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(60797).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ShenyuClientMetadataExecutorSubscriber#executor()")),(0,r.kt)("p",null,"The metadata processing logic on the client side is: iterate through the metadata information and call the interface method ",(0,r.kt)("inlineCode",{parentName:"p"},"persistInterface()")," to finish publishing the data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class ShenyuClientMetadataExecutorSubscriber implements ExecutorTypeSubscriber<MetaDataRegisterDTO> {\n   \n    //......\n    \n    @Override\n    public DataType getType() {\n        return DataType.META_DATA; \n    }\n    \n    @Override\n    public void executor(final Collection<MetaDataRegisterDTO> metaDataRegisterDTOList) {\n        for (MetaDataRegisterDTO metaDataRegisterDTO : metaDataRegisterDTOList) {\n            // call the interface method persistInterface() to finish publishing the data\n            shenyuClientRegisterRepository.persistInterface(metaDataRegisterDTO);\n        }\n    }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ShenyuClientRegisterRepository#persistInterface()")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterRepository")," is an interface to represent client-side data registration, and it has five implementation classes at present, each of which represents a registration method."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ConsulClientRegisterRepository"),": client registration is achieved through ",(0,r.kt)("inlineCode",{parentName:"li"},"Consul"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EtcdClientRegisterRepository"),": client registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HttpClientRegisterRepository"),": client registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Http"),"; ",(0,r.kt)("inlineCode",{parentName:"li"},"NacosClientRegisterRepository"),": client registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Http"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NacosClientRegisterRepository"),": client registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Nacos"),"; ",(0,r.kt)("inlineCode",{parentName:"li"},"ZookeeperClientRegisterRepository"),": client registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Nacos"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZookeeperClientRegisterRepository"),": client registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Zookeeper"),".")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(79568).Z})),(0,r.kt)("p",null,"As you can see from the diagram, the loading of the registry is done by means of ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),". This was mentioned earlier, and the specific class loading is done in the client-side generic configuration file by specifying the properties in the configuration file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n * load ShenyuClientRegisterRepository\n */\npublic final class ShenyuClientRegisterRepositoryFactory {\n    \n    private static final Map<String, ShenyuClientRegisterRepository> REPOSITORY_MAP = new ConcurrentHashMap<>();\n    \n    /**\n     * create ShenyuClientRegisterRepository\n     */\n    public static ShenyuClientRegisterRepository newInstance(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig) {\n        if (!REPOSITORY_MAP.containsKey(shenyuRegisterCenterConfig.getRegisterType())) {\n            // loading by means of SPI, type determined by registerType\n            ShenyuClientRegisterRepository result = ExtensionLoader.getExtensionLoader(ShenyuClientRegisterRepository.class).getJoin(shenyuRegisterCenterConfig.getRegisterType());\n            // perform initialization operations\n            result.init(shenyuRegisterCenterConfig);\n            ShenyuClientShutdownHook.set(result, shenyuRegisterCenterConfig.getProps());\n            REPOSITORY_MAP.put(shenyuRegisterCenterConfig.getRegisterType(), result);\n            return result;\n        }\n        return REPOSITORY_MAP.get(shenyuRegisterCenterConfig.getRegisterType());\n    }\n}\n")),(0,r.kt)("p",null,"The source code analysis in this article is based on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Http")," way of registration, so we first analyze the ",(0,r.kt)("inlineCode",{parentName:"p"},"HttpClientRegisterRepository"),", and the other registration methods will be analyzed afterwards."),(0,r.kt)("p",null,"Registration by way of ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," is very simple, it is to call the tool class to send ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," requests. The registration metadata and URI are both called by the same method ",(0,r.kt)("inlineCode",{parentName:"p"},"doRegister()"),", specifying the interface and type."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/shenyu-client/register-metadata"),": the interface provided by the server for registering metadata."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/shenyu-client/register-uri"),": Server-side interface for registering URIs.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Join\npublic class HttpClientRegisterRepository implements ShenyuClientRegisterRepository {\n    // server-side provided interface for registering metadata    \n    private static final String META_PATH = "/shenyu-client/register-metadata";\n\n    // the interface provided by the server for registering URIs\n    private static final String URI_PATH = "/shenyu-client/register-uri";\n\n    @Override\n    public void persistURI(final URIRegisterDTO registerDTO) {\n        doRegister(registerDTO, URI_PATH, Constants.URI);\n    }\n    \n    @Override\n    public void persistInterface(final MetaDataRegisterDTO metadata) {\n        doRegister(metadata, META_PATH, META_TYPE);\n    }\n    \n    // do register\n    private <T> void doRegister(final T t, final String path, final String type) {\n        // iterate through the list of admin services (admin may be clustered)\n        for (String server : serverList) {\n            try {\n                // calling the tool class to send http requests\n                RegisterUtils.doRegister(GsonUtils.getInstance().toJson(t), server + path, type);\n                return;\n            } catch (Exception e) {\n                LOGGER.error("register admin url :{} is fail, will retry", server);\n            }\n        }\n    }\n}\n\n')),(0,r.kt)("p",null,"Serialize the data and send it via ",(0,r.kt)("inlineCode",{parentName:"p"},"OkHttp"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\npublic final class RegisterUtils {\n   \n   //...... \n\n    // Sending data via OkHttp\n    public static void doRegister(final String json, final String url, final String type) throws IOException {\n        String result = OkHttpTools.getInstance().post(url, json);\n        if (Objects.equals(SUCCESS, result)) {\n            LOGGER.info("{} client register success: {} ", type, json);\n        } else {\n            LOGGER.error("{} client register error: {} ", type, json);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"At this point, the logic of the client registering metadata by means of ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," is finished. To summarize: construct metadata by reading custom annotation information, send the data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue, then consume the data from the queue, put the consumer into the thread pool to execute, and finally send an ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," request to the ",(0,r.kt)("inlineCode",{parentName:"p"},"admin"),"."),(0,r.kt)("p",null,"The source code analysis process of the client-side metadata registration process is completed and described in a flowchart as follows."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(57052).Z})),(0,r.kt)("h4",{id:"24-contextregisterlistener"},"2.4 ContextRegisterListener"),(0,r.kt)("p",null,"Create ",(0,r.kt)("inlineCode",{parentName:"p"},"ContextRegisterListener"),", which is responsible for the construction and registration of client-side ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data, and its creation is done in the configuration file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Configuration\n@ImportAutoConfiguration(ShenyuClientCommonBeanConfiguration.class)\npublic class ShenyuSpringMvcClientConfiguration {\n     // ......\n    \n    // create ContextRegisterListener\n    @Bean\n    public ContextRegisterListener contextRegisterListener(final ShenyuClientConfig clientConfig) {\n        return new ContextRegisterListener(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()));\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ContextRegisterListener")," implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"ApplicationListener")," interface and overrides the ",(0,r.kt)("inlineCode",{parentName:"p"},"onApplicationEvent()")," method, which is executed when a Spring event occurs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class ContextRegisterListener implements ApplicationListener<ContextRefreshedEvent> {\n\n     //......\n\n    //Instantiation is done through the constructor\n    public ContextRegisterListener(final PropertiesConfig clientConfig) {\n        // read shenyu.client.http properties\n        Properties props = clientConfig.getProps();\n        // isFull\n        this.isFull = Boolean.parseBoolean(props.getProperty(ShenyuClientConstants.IS_FULL, Boolean.FALSE.toString()));\n        // contextPath\n        String contextPath = props.getProperty(ShenyuClientConstants.CONTEXT_PATH);\n        this.contextPath = contextPath;\n        if (isFull) {\n            if (StringUtils.isBlank(contextPath)) {\n                String errorMsg = "http register param must config the contextPath";\n                LOG.error(errorMsg);\n                throw new ShenyuClientIllegalArgumentException(errorMsg);\n            }\n            this.contextPath = contextPath + "/**";\n        }\n        // port \n        int port = Integer.parseInt(props.getProperty(ShenyuClientConstants.PORT));\n        // appName \n        this.appName = props.getProperty(ShenyuClientConstants.APP_NAME);\n        // host\n        this.host = props.getProperty(ShenyuClientConstants.HOST);\n        this.port = port;\n    }\n\n    // This method is executed when a context refresh event(ContextRefreshedEvent), occurs\n    @Override\n    public void onApplicationEvent(@NonNull final ContextRefreshedEvent contextRefreshedEvent) {\n        // The contents of the method are guaranteed to be executed only once\n        if (!registered.compareAndSet(false, true)) {\n            return;\n        }\n        // If isFull=true means register the entire service, build the metadata and register\n        if (isFull) {\n            publisher.publishEvent(buildMetaDataDTO());\n        }\n        \n        // build URI data and register it\n        publisher.publishEvent(buildURIRegisterDTO());\n    }\n\n    // build URI data \n    private URIRegisterDTO buildURIRegisterDTO() {\n        String host = IpUtils.isCompleteHost(this.host) ? this.host : IpUtils.getHost(this.host);\n        return URIRegisterDTO.builder()\n                .contextPath(this.contextPath)\n                .appName(appName)\n                .host(host)\n                .port(port)\n                .rpcType(RpcTypeEnum.HTTP.getName())\n                .build();\n    }\n\n    // build metadata\n    private MetaDataRegisterDTO buildMetaDataDTO() {\n        String contextPath = this.contextPath;\n        String appName = this.appName;\n        return MetaDataRegisterDTO.builder()\n                .contextPath(contextPath)\n                .appName(appName)\n                .path(contextPath)\n                .rpcType(RpcTypeEnum.HTTP.getName())\n                .enabled(true)\n                .ruleName(contextPath)\n                .build();\n    }\n}\n\n')),(0,r.kt)("p",null,"The main thing in the constructor is to read the property configuration."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"onApplicationEvent()")," method is executed when a ",(0,r.kt)("inlineCode",{parentName:"p"},"Spring")," event occurs, the parameter here is ",(0,r.kt)("inlineCode",{parentName:"p"},"ContextRefreshedEvent"),", which means the context refresh event. The logic here is executed when the ",(0,r.kt)("inlineCode",{parentName:"p"},"Spring")," container is ready: if ",(0,r.kt)("inlineCode",{parentName:"p"},"isFull=true")," means register the whole service, build the metadata and register it, the case ",(0,r.kt)("inlineCode",{parentName:"p"},"isFull=true")," is not handled in the post-processor ",(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvcClientBeanPostProcessor")," analyzed earlier, so here it is processing. Then the ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data is constructed and registered."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"ContextRefreshedEvent")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Spring")," built-in event. It is fired when the ",(0,r.kt)("inlineCode",{parentName:"p"},"ApplicationContext")," is initialized or refreshed. This can also happen in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ConfigurableApplicationContext")," interface using the ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh()")," method. Initialization here means that all ",(0,r.kt)("inlineCode",{parentName:"p"},"Bean"),"s have been successfully loaded, post-processing ",(0,r.kt)("inlineCode",{parentName:"p"},"Bean"),"s have been detected and activated, all ",(0,r.kt)("inlineCode",{parentName:"p"},"Singleton Bean"),"s have been pre-instantiated, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"ApplicationContext")," container is ready to be used.")),(0,r.kt)("p",null,"The registration logic is done through ",(0,r.kt)("inlineCode",{parentName:"p"},"publisher.publishEvent()"),". It has been analyzed earlier: data is written to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue, consumed from it, and finally processed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutorSubscriber"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ExecutorSubscriber#executor()")),(0,r.kt)("p",null,"The actuator subscribers are divided into two categories, one that handles metadata and one that handles ",(0,r.kt)("inlineCode",{parentName:"p"},"URIs"),". There are two on the client side and two on the server side, so there are four in total."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(60797).Z})),(0,r.kt)("p",null,"Here is the registration ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," information, so the execution class is ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientURIExecutorSubscriber"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ShenyuClientURIExecutorSubscriber#executor()")),(0,r.kt)("p",null,"The main logic is to iterate through the URI data collection and implement data registration through the ",(0,r.kt)("inlineCode",{parentName:"p"},"persistURI()")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\npublic class ShenyuClientURIExecutorSubscriber implements ExecutorTypeSubscriber<URIRegisterDTO> {\n    \n    //......\n    \n    @Override\n    public DataType getType() {\n        return DataType.URI; \n    }\n    \n    // register URI\n    @Override\n    public void executor(final Collection<URIRegisterDTO> dataList) {\n        for (URIRegisterDTO uriRegisterDTO : dataList) {\n            Stopwatch stopwatch = Stopwatch.createStarted();\n            while (true) {\n                try (Socket ignored = new Socket(uriRegisterDTO.getHost(), uriRegisterDTO.getPort())) {\n                    break;\n                } catch (IOException e) {\n                    long sleepTime = 1000;\n                    // maybe the port is delay exposed\n                    if (stopwatch.elapsed(TimeUnit.SECONDS) > 5) {\n                        LOG.error("host:{}, port:{} connection failed, will retry",\n                                uriRegisterDTO.getHost(), uriRegisterDTO.getPort());\n                        // If the connection fails for a long time, Increase sleep time\n                        if (stopwatch.elapsed(TimeUnit.SECONDS) > 180) {\n                            sleepTime = 10000;\n                        }\n                    }\n                    try {\n                        TimeUnit.MILLISECONDS.sleep(sleepTime);\n                    } catch (InterruptedException ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n            ShenyuClientShutdownHook.delayOtherHooks();\n            \n            shenyuClientRegisterRepository.persistURI(uriRegisterDTO);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"while(true)")," loop in the code is to ensure that the client has been successfully started and can connect via ",(0,r.kt)("inlineCode",{parentName:"p"},"host")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"port"),"."),(0,r.kt)("p",null,"The logic behind it is: add the ",(0,r.kt)("inlineCode",{parentName:"p"},"hook")," function for gracefully stopping the client ."),(0,r.kt)("p",null,"Data registration is achieved through the ",(0,r.kt)("inlineCode",{parentName:"p"},"persistURI()")," method. The whole logic is also analyzed in the previous section, and ultimately it is the ",(0,r.kt)("inlineCode",{parentName:"p"},"OkHttp")," client that initiates ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin")," and registers the ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," by way of ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),"."),(0,r.kt)("p",null,"The analysis of the registration logic of the client is finished here, and the metadata and URI data constructed are sent to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue, from which they are then consumed, read, and sent to ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," via ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),"."),(0,r.kt)("p",null,"The source code analysis of the client-side ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," registration process is complete, with the following flow chart."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(96154).Z})),(0,r.kt)("h3",{id:"3-server-side-registration-process"},"3. Server-side registration process"),(0,r.kt)("h4",{id:"31-shenyuhttpregistrycontroller"},"3.1 ShenyuHttpRegistryController"),(0,r.kt)("p",null,"From the previous analysis, we know that the server side provides two interfaces for registration."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/shenyu-client/register-metadata"),": The interface provided by the server side is used to register metadata."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/shenyu-client/register-uri"),": The server-side interface is provided for registering URIs.")),(0,r.kt)("p",null,"These two interfaces are located in ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuHttpRegistryController"),", which implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuServerRegisterRepository")," interface and is the implementation class for server-side registration. It is marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@Join")," to indicate loading via ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@RequestMapping("/shenyu-client")\n@Join\npublic class ShenyuHttpRegistryController implements ShenyuServerRegisterRepository {\n\n    private ShenyuServerRegisterPublisher publisher;\n\n    @Override\n    public void init(final ShenyuServerRegisterPublisher publisher, final ShenyuRegisterCenterConfig config) {\n        this.publisher = publisher;\n    }\n    \n    // register Metadata\n    @PostMapping("/register-metadata")\n    @ResponseBody\n    public String registerMetadata(@RequestBody final MetaDataRegisterDTO metaDataRegisterDTO) {\n        publish(metaDataRegisterDTO);\n        return ShenyuResultMessage.SUCCESS;\n    }\n        \n   // register URI\n    @PostMapping("/register-uri")\n    @ResponseBody\n    public String registerURI(@RequestBody final URIRegisterDTO uriRegisterDTO) {\n        publish(uriRegisterDTO);\n        return ShenyuResultMessage.SUCCESS;\n    }\n\n    // publish event\n    private <T> void publish(final T t) {\n        publisher.publish(Collections.singletonList(t));\n    }\n}\n\n')),(0,r.kt)("p",null,"The two registration interfaces get the data well and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"publish()")," method to publish the data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuServerRegisterRepository"))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuServerRegisterRepository")," interface is a service registration interface, which has five implementation classes, indicating five types of registration."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ConsulServerRegisterRepository"),": registration is achieved through ",(0,r.kt)("inlineCode",{parentName:"li"},"Consul"),";"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EtcdServerRegisterRepository"),": registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NacosServerRegisterRepository"),": registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Nacos"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuHttpRegistryController"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Http"),"; ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuHttpRegistryController"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Http"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZookeeperServerRegisterRepository"),": registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Zookeeper"),".")),(0,r.kt)("p",null,"The exact method used is specified by the configuration file and then loaded via ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),"."),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"application.yml")," file in ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin")," configure the registration method, ",(0,r.kt)("inlineCode",{parentName:"p"},"registerType")," specify the registration type, when registering with ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"serverLists")," do not need to be filled in, for more configuration instructions you can refer to the official website ",(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/zh/docs/user-guide/register-center-access"},"Client Access Configuration"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"shenyu:\n  register:\n    registerType: http \n    serverLists: \n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"RegisterCenterConfiguration ")),(0,r.kt)("p",null,"After introducing the relevant dependencies and properties configuration, when starting ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin"),", the configuration file will be loaded first, and the configuration file class related to the registration center is ",(0,r.kt)("inlineCode",{parentName:"p"},"RegisterCenterConfiguration"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Configuration\npublic class RegisterCenterConfiguration {\n    @Bean\n    @ConfigurationProperties(prefix = "shenyu.register")\n    public ShenyuRegisterCenterConfig shenyuRegisterCenterConfig() {\n        return new ShenyuRegisterCenterConfig();\n    }\n    \n    //create ShenyuServerRegisterRepository to register in admin\n    @Bean\n    public ShenyuServerRegisterRepository shenyuServerRegisterRepository(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig, final List<ShenyuClientRegisterService> shenyuClientRegisterService) {\n        // 1. get the registration type from the configuration property\n        String registerType = shenyuRegisterCenterConfig.getRegisterType();\n        // 2. load the implementation class by registering the type with the SPI method\n        ShenyuServerRegisterRepository registerRepository = ExtensionLoader.getExtensionLoader(ShenyuServerRegisterRepository.class).getJoin(registerType);\n        // 3. get the publisher and write data to the Disruptor queue\n        RegisterServerDisruptorPublisher publisher = RegisterServerDisruptorPublisher.getInstance();\n        // 4. ShenyuClientRegisterService, rpcType -> registerService\n        Map<String, ShenyuClientRegisterService> registerServiceMap = shenyuClientRegisterService.stream().collect(Collectors.toMap(ShenyuClientRegisterService::rpcType, e -> e));\n        // 5. start publisher\n        publisher.start(registerServiceMap);\n        // 6. init registerRepository\n        registerRepository.init(publisher, shenyuRegisterCenterConfig);\n        return registerRepository;\n    }\n}\n\n')),(0,r.kt)("p",null,"Two ",(0,r.kt)("inlineCode",{parentName:"p"},"bean"),"s are generated in the configuration class."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"shenyuRegisterCenterConfig"),": to read the attribute configuration.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"shenyuServerRegisterRepository"),": for server-side registration."))),(0,r.kt)("p",null,"In the process of creating ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyuServerRegisterRepository"),", a series of preparations are also performed."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"get the registration type from the configuration property."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:2},(0,r.kt)("li",{parentName:"ol"},"Load the implementation class by the registration type with the ",(0,r.kt)("inlineCode",{parentName:"li"},"SPI")," method: for example, if the specified type is ",(0,r.kt)("inlineCode",{parentName:"li"},"http"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuHttpRegistryController")," will be loaded."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:3},(0,r.kt)("li",{parentName:"ol"},"Get ",(0,r.kt)("inlineCode",{parentName:"li"},"publisher")," and write data to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Disruptor")," queue."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:4},(0,r.kt)("li",{parentName:"ol"},"Register ",(0,r.kt)("inlineCode",{parentName:"li"},"Service"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"rpcType -> registerService"),": get the registered ",(0,r.kt)("inlineCode",{parentName:"li"},"Service"),", each ",(0,r.kt)("inlineCode",{parentName:"li"},"rpc")," has a corresponding ",(0,r.kt)("inlineCode",{parentName:"li"},"Service"),". The client for this article is built through ",(0,r.kt)("inlineCode",{parentName:"li"},"springboot"),", which belongs to the ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," type, and other client types: ",(0,r.kt)("inlineCode",{parentName:"li"},"dubbo"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Spring Cloud"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"gRPC"),", etc."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:5},(0,r.kt)("li",{parentName:"ol"},"Preparation for event publishing: add server-side metadata and ",(0,r.kt)("inlineCode",{parentName:"li"},"URI")," subscribers, process the data. And start the ",(0,r.kt)("inlineCode",{parentName:"li"},"Disruptor")," queue."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:6},(0,r.kt)("li",{parentName:"ol"},"Initialization operation for registration: ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," type registration initialization operation is to save ",(0,r.kt)("inlineCode",{parentName:"li"},"publisher"),".")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"RegisterServerDisruptorPublisher#publish()")),(0,r.kt)("p",null,"The server-side publisher that writes data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue , built via the singleton pattern."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic class RegisterServerDisruptorPublisher implements ShenyuServerRegisterPublisher {\n    private static final RegisterServerDisruptorPublisher INSTANCE = new RegisterServerDisruptorPublisher();\n\n    public static RegisterServerDisruptorPublisher getInstance() {\n        return INSTANCE;\n    }\n    \n   //prepare for event publishing, add server-side metadata and URI subscribers, process data. And start the Disruptor queue.\n    public void start(final Map<String, ShenyuClientRegisterService> shenyuClientRegisterService) {\n        factory = new RegisterServerExecutorFactory();\n        // add URI data subscriber\n        factory.addSubscribers(new URIRegisterExecutorSubscriber(shenyuClientRegisterService));\n        // add Metadata subscriber\n        factory.addSubscribers(new MetadataExecutorSubscriber(shenyuClientRegisterService));\n        //start Disruptor\n        providerManage = new DisruptorProviderManage(factory);\n        providerManage.startup();\n    }\n    \n    // write data to queue\n    @Override\n    public <T> void publish(final T data) {\n        DisruptorProvider<Object> provider = providerManage.getProvider();\n        provider.onData(f -> f.setData(data));\n    }\n    \n    @Override\n    public void close() {\n        providerManage.getProvider().shutdown();\n    }\n}\n")),(0,r.kt)("p",null,"The loading of the configuration file, which can be seen as the initialization process of the registry server, is described in the following diagram."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(99019).Z})),(0,r.kt)("h4",{id:"32-queueconsumer"},"3.2 QueueConsumer"),(0,r.kt)("p",null,"In the previous analysis of the client-side ",(0,r.kt)("inlineCode",{parentName:"p"},"disruptor")," queue consumption of data over. The server side has the same logic, except that the executor performing the task changes."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumer")," is a consumer that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"WorkHandler")," interface, which is created in the ",(0,r.kt)("inlineCode",{parentName:"p"},"providerManage.startup()")," logic. The ",(0,r.kt)("inlineCode",{parentName:"p"},"WorkHandler")," interface is the data consumption interface for ",(0,r.kt)("inlineCode",{parentName:"p"},"disruptor"),", and the only method is ",(0,r.kt)("inlineCode",{parentName:"p"},"onEvent()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"package com.lmax.disruptor;\n\npublic interface WorkHandler<T> {\n    void onEvent(T var1) throws Exception;\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumer")," overrides the ",(0,r.kt)("inlineCode",{parentName:"p"},"onEvent()")," method, and the main logic is to generate the consumption task and then go to the thread pool to execute it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * \n * QueueConsumer\n */\npublic class QueueConsumer<T> implements WorkHandler<DataEvent<T>> {\n    \n    // ......\n\n    @Override\n    public void onEvent(final DataEvent<T> t) {\n        if (t != null) {\n            // create queue consumption tasks via factory\n            QueueConsumerExecutor<T> queueConsumerExecutor = factory.create();\n            // set data\n            queueConsumerExecutor.setData(t.getData());\n            // help gc\n            t.setData(null);\n            // put in the thread pool to execute the consumption task\n            executor.execute(queueConsumerExecutor);\n        }\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumerExecutor")," is the task that is executed in the thread pool, it implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runnable")," interface, and there are two specific implementation classes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterClientConsumerExecutor"),": the client-side consumer executor."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterServerConsumerExecutor"),": server-side consumer executor.")),(0,r.kt)("p",null,"As the name implies, one is responsible for handling client-side tasks and one is responsible for handling server-side tasks."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterServerConsumerExecutor#run()"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RegisterServerConsumerExecutor")," is a server-side consumer executor that indirectly implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runnable")," interface via ",(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumerExecutor")," and overrides the ",(0,r.kt)("inlineCode",{parentName:"p"},"run()")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic final class RegisterServerConsumerExecutor extends QueueConsumerExecutor<List<DataTypeParent>> {\n   // ...\n\n    @Override\n    public void run() {\n        //get the data from the disruptor queue\n        List<DataTypeParent> results = getData();\n        // check data\n        results = results.stream().filter(data -> isValidData(data)).collect(Collectors.toList());\n        if (CollectionUtils.isEmpty(results)) {\n            return;\n        }\n        //execute operations according to type\n        getType(results).executor(results);\n    }\n    \n    // get subscribers by type\n    private ExecutorSubscriber getType(final List<DataTypeParent> list) {\n        DataTypeParent result = list.get(0);\n        return subscribers.get(result.getType());\n    }\n}\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ExecutorSubscriber#executor()")),(0,r.kt)("p",null,"The actuator subscribers are divided into two categories, one that handles metadata and one that handles ",(0,r.kt)("inlineCode",{parentName:"p"},"URIs"),". There are two on the client side and two on the server side, so there are four in total."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(60797).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"MetadataExecutorSubscriber#executor()")),(0,r.kt)("p",null,"In case of registering metadata, this is achieved by ",(0,r.kt)("inlineCode",{parentName:"p"},"MetadataExecutorSubscriber#executor()"),": get the registered ",(0,r.kt)("inlineCode",{parentName:"p"},"Service")," according to the type and call ",(0,r.kt)("inlineCode",{parentName:"p"},"register()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class MetadataExecutorSubscriber implements ExecutorTypeSubscriber<MetaDataRegisterDTO> {\n \n    //......\n\n    @Override\n    public DataType getType() {\n        return DataType.META_DATA; \n    }\n\n    @Override\n    public void executor(final Collection<MetaDataRegisterDTO> metaDataRegisterDTOList) {\n        // Traversing the metadata list\n        for (MetaDataRegisterDTO metaDataRegisterDTO : metaDataRegisterDTOList) {\n            // Get registered Service by type\n            ShenyuClientRegisterService shenyuClientRegisterService = this.shenyuClientRegisterService.get(metaDataRegisterDTO.getRpcType());\n            Objects.requireNonNull(shenyuClientRegisterService);\n            // Registration of metadata, locking to ensure sequential execution and prevent concurrent errors\n            synchronized (ShenyuClientRegisterService.class) {\n                shenyuClientRegisterService.register(metaDataRegisterDTO);\n            }\n        }\n    }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"URIRegisterExecutorSubscriber#executor()")),(0,r.kt)("p",null,"In case of registration metadata, this is achieved by ",(0,r.kt)("inlineCode",{parentName:"p"},"URIRegisterExecutorSubscriber#executor()"),": construct ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data, find ",(0,r.kt)("inlineCode",{parentName:"p"},"Service")," according to the registration type, and achieve registration by the ",(0,r.kt)("inlineCode",{parentName:"p"},"registerURI")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic class URIRegisterExecutorSubscriber implements ExecutorTypeSubscriber<URIRegisterDTO> {\n    //......\n    \n    @Override\n    public DataType getType() {\n        return DataType.URI; \n    }\n    \n    @Override\n    public void executor(final Collection<URIRegisterDTO> dataList) {\n        if (CollectionUtils.isEmpty(dataList)) {\n            return;\n        }\n        // Build URI data types and register them with the registerURI method\n        findService(dataList).ifPresent(service -> {\n            Map<String, List<URIRegisterDTO>> listMap = buildData(dataList);\n            listMap.forEach(service::registerURI);\n        });\n    }\n    \n    // Find Service by type\n    private Optional<ShenyuClientRegisterService> findService(final Collection<URIRegisterDTO> dataList) {\n        return dataList.stream().map(dto -> shenyuClientRegisterService.get(dto.getRpcType())).findFirst();\n    }\n}\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ShenyuClientRegisterService#register()")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterService")," is the registration method interface, which has several implementation classes."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(76122).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AbstractContextPathRegisterService"),": abstract class, handling part of the public logic."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AbstractShenyuClientRegisterServiceImpl"),": : abstract class, handles part of the public logic."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterDivideServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"divide")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterDubboServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"dubbo")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"dubbo")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterGrpcServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"gRPC")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"gRPC")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterMotanServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Motan")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"Motan")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterSofaServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Sofa")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"Sofa")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterSpringCloudServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"SpringCloud")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"SpringCloud")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterTarsServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Tars")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"Tars")," registration types.")),(0,r.kt)("p",null,"From the above, we can see that each microservice has a corresponding registration implementation class. The source code analysis in this article is based on the official ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/apache/incubator-shenyu/tree/master/shenyu-examples/shenyu-examples-http"},"shenyu-examples-http")," as an example, it is of ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," registration type, so the registration implementation class for metadata and URI data is ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterDivideServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterDivideServiceImpl"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"register(): ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public String register(final MetaDataRegisterDTO dto) {\n        // 1.register selector information\n        String selectorHandler = selectorHandler(dto);\n        String selectorId = selectorService.registerDefault(dto, PluginNameAdapter.rpcTypeAdapter(rpcType()), selectorHandler);\n        // 2.register rule information\n        String ruleHandler = ruleHandler();\n        RuleDTO ruleDTO = buildRpcDefaultRuleDTO(selectorId, dto, ruleHandler);\n        ruleService.registerDefault(ruleDTO);\n        // 3.register metadata information\n        registerMetadata(dto);\n        // 4.register contextPath\n        String contextPath = dto.getContextPath();\n        if (StringUtils.isNotEmpty(contextPath)) {\n            registerContextPath(dto);\n        }\n        return ShenyuResultMessage.SUCCESS;\n    }\n")),(0,r.kt)("p",null,"The whole registration logic can be divided into 4 steps."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Register selector information"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:2},(0,r.kt)("li",{parentName:"ol"},"Register rule information"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:3},(0,r.kt)("li",{parentName:"ol"},"Register metadata information"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:4},(0,r.kt)("li",{parentName:"ol"},"Register `contextPath")))),(0,r.kt)("p",null,"This side of ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," requires the construction of selectors, rules, metadata and ",(0,r.kt)("inlineCode",{parentName:"p"},"ContextPath")," through the metadata information of the client. The specific registration process and details of processing are related to the ",(0,r.kt)("inlineCode",{parentName:"p"},"rpc")," type. We will not continue to track down the logical analysis of the registration center, tracking to this point is enough."),(0,r.kt)("p",null,"The source code of the server-side metadata registration process is analyzed and the flow chart is described as follows."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(25808).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"registerURI()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public String registerURI(final String selectorName, final List<URIRegisterDTO> uriList) {\n        if (CollectionUtils.isEmpty(uriList)) {\n            return "";\n        }\n        // Does the corresponding selector exist\n        SelectorDO selectorDO = selectorService.findByNameAndPluginName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\n        if (Objects.isNull(selectorDO)) {\n            return "";\n        }\n        // Handle handler information in the selector\n        String handler = buildHandle(uriList, selectorDO);\n        selectorDO.setHandle(handler);\n        SelectorData selectorData = selectorService.buildByName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\n        selectorData.setHandle(handler);\n       \n        // Update records in the database\n        selectorService.updateSelective(selectorDO);\n        // publish Event to gateway\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE, Collections.singletonList(selectorData)));\n        return ShenyuResultMessage.SUCCESS;\n    }\n')),(0,r.kt)("p",null,"After ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," gets the ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data, it mainly updates the ",(0,r.kt)("inlineCode",{parentName:"p"},"handler")," information in the selector, then writes it to the database, and finally publishes the event notification gateway. The logic of notifying the gateway is done by the data synchronization operation, which has been analyzed in the previous article, so we will not repeat it."),(0,r.kt)("p",null,"The source code analysis of the server-side ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," registration process is complete and is described in the following diagram."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(33844).Z})),(0,r.kt)("p",null,"At this point, the server-side registration process is also analyzed, mainly through the interface provided externally, accept the registration information from the client, and then write to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue, and then consume data from it, and update the ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," selector, rules, metadata and selector ",(0,r.kt)("inlineCode",{parentName:"p"},"handler")," according to the received metadata and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data."),(0,r.kt)("h3",{id:"4-summary"},"4. Summary"),(0,r.kt)("p",null,"This article focuses on the ",(0,r.kt)("inlineCode",{parentName:"p"},"http registration")," module of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Apache ShenYu")," gateway for source code analysis. The main knowledge points involved are summarized as follows."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The register center is for registering client information to ",(0,r.kt)("inlineCode",{parentName:"li"},"admin")," to facilitate traffic filtering."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"http")," registration is to register client metadata information and ",(0,r.kt)("inlineCode",{parentName:"li"},"URI")," information to ",(0,r.kt)("inlineCode",{parentName:"li"},"admin"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"http")," service access is identified by the annotation ",(0,r.kt)("inlineCode",{parentName:"li"},"@ShenyuSpringMvcClient"),"."),(0,r.kt)("li",{parentName:"ul"},"construction of the registration information mainly through the ",(0,r.kt)("inlineCode",{parentName:"li"},"Spring")," post-processor ",(0,r.kt)("inlineCode",{parentName:"li"},"BeanPostProcessor")," and the application listener ",(0,r.kt)("inlineCode",{parentName:"li"},"ApplicationListener"),"."),(0,r.kt)("li",{parentName:"ul"},"loading of the registration type is done through ",(0,r.kt)("inlineCode",{parentName:"li"},"SPI"),"."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Disruptor")," queue was introduced to decouple data from operations, and data buffering."),(0,r.kt)("li",{parentName:"ul"},"The implementation of the registry uses interface-oriented programming, using design patterns such as template methods, singleton, and observer.")))}u.isMDXComponent=!0},57052:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-metadata-register-en-61c164173cb334f7a4437da695aa58c4.png"},98557:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-register-init-en-26f782b8789e3805586b6af8d4e91429.png"},79568:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-register-repository-61756e3284c1d3a27083b25d393edf9c.png"},76122:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-register-service-5dff35d87a76f01373cdd702d1217b3b.png"},96154:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-uri-register-en-0b05799abad7ebd3c380797a952c2f15.png"},5847:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/consumer-executor-f7ad67d35abaa5a2fac94ef913445a19.png"},60797:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/executor-subscriber-86d5645d204ad1d05fe12dd30992c8d1.png"},34177:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/register-center-en-d38e8150e48eec9bef3727dbadc124ec.png"},25808:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/server-metadata-register-en-8290907a57a1189a4b5863f3c47254bb.png"},99019:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/server-register-init-en-c20ecd9991817e159730a8aea38db110.png"},33844:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/server-uri-register-en-6026d791dbc404cadee04b237add0691.png"},47868:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/shenyu-client-register-repository-57035be945a0a8fc435049c13c0dac57.png"},10318:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/shenyu-register-center-en-732853d1dc114c56034d14f70e92be06.png"},13210:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/shenyu-register-center-http-en-2bf3e3a1e2c72d3fca6059fae46886f8.png"}}]);